<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">572</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Assignment Expressions</td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Chris Angelico &lt;rosuav&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">28-Feb-2018</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.8</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">28-Feb-2018, 02-Mar-2018, 23-Mar-2018, 04-Apr-2018</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id3">Rationale</a></li>
<li><a class="reference internal" href="#syntax-and-semantics" id="id4">Syntax and semantics</a><ul>
<li><a class="reference internal" href="#differences-from-regular-assignment-statements" id="id5">Differences from regular assignment statements</a></li>
<li><a class="reference internal" href="#alterations-to-comprehensions" id="id6">Alterations to comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#recommended-use-cases" id="id7">Recommended use-cases</a><ul>
<li><a class="reference internal" href="#simplifying-list-comprehensions" id="id8">Simplifying list comprehensions</a></li>
<li><a class="reference internal" href="#capturing-condition-values" id="id9">Capturing condition values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rejected-alternative-proposals" id="id10">Rejected alternative proposals</a><ul>
<li><a class="reference internal" href="#alternative-spellings" id="id11">Alternative spellings</a></li>
<li><a class="reference internal" href="#special-casing-conditional-statements" id="id12">Special-casing conditional statements</a></li>
<li><a class="reference internal" href="#special-casing-comprehensions" id="id13">Special-casing comprehensions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#migration-path" id="id14">Migration path</a><ul>
<li><a class="reference internal" href="#yield-inside-comprehensions" id="id15">Yield inside comprehensions</a></li>
<li><a class="reference internal" href="#name-lookups-in-class-scope" id="id16">Name lookups in class scope</a></li>
<li><a class="reference internal" href="#generator-expression-bugs-can-be-caught-later" id="id17">Generator expression bugs can be caught later</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-questions" id="id18">Open questions</a><ul>
<li><a class="reference internal" href="#can-the-outermost-iterable-still-be-evaluated-early" id="id19">Can the outermost iterable still be evaluated early?</a></li>
<li><a class="reference internal" href="#importing-names-into-comprehensions" id="id20">Importing names into comprehensions</a></li>
<li><a class="reference internal" href="#operator-precedence" id="id21">Operator precedence</a></li>
</ul>
</li>
<li><a class="reference internal" href="#frequently-raised-objections" id="id22">Frequently Raised Objections</a><ul>
<li><a class="reference internal" href="#why-not-just-turn-existing-assignment-into-an-expression" id="id23">Why not just turn existing assignment into an expression?</a></li>
<li><a class="reference internal" href="#this-could-be-used-to-create-ugly-code" id="id24">This could be used to create ugly code!</a></li>
<li><a class="reference internal" href="#with-assignment-expressions-why-bother-with-assignment-statements" id="id25">With assignment expressions, why bother with assignment statements?</a></li>
<li><a class="reference internal" href="#why-not-use-a-sublocal-scope-and-prevent-namespace-pollution" id="id26">Why not use a sublocal scope and prevent namespace pollution?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#style-guide-recommendations" id="id27">Style guide recommendations</a></li>
<li><a class="reference internal" href="#acknowledgements" id="id28">Acknowledgements</a></li>
<li><a class="reference internal" href="#references" id="id29">References</a></li>
<li><a class="reference internal" href="#copyright" id="id30">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>This is a proposal for creating a way to assign to names within an expression.
Additionally, the precise scope of comprehensions is adjusted, to maintain
consistency and follow expectations.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id3">Rationale</a></h1>
<p>Naming the result of an expression is an important part of programming,
allowing a descriptive name to be used in place of a longer expression,
and permitting reuse.  Currently, this feature is available only in
statement form, making it unavailable in list comprehensions and other
expression contexts.  Merely introducing a way to assign as an expression
would create bizarre edge cases around comprehensions, though, and to avoid
the worst of the confusions, we change the definition of comprehensions,
causing some edge cases to be interpreted differently, but maintaining the
existing behaviour in the majority of situations.</p>
</div>
<div class="section" id="syntax-and-semantics">
<h1><a class="toc-backref" href="#id4">Syntax and semantics</a></h1>
<p>In any context where arbitrary Python expressions can be used, a <strong>named
expression</strong> can appear. This is of the form <tt class="docutils literal">target := expr</tt> where
<tt class="docutils literal">expr</tt> is any valid Python expression, and <tt class="docutils literal">target</tt> is any valid
assignment target. (NOTE: See 'Open questions' below for precedence.)</p>
<p>The value of such a named expression is the same as the incorporated
expression, with the additional side-effect that the target is assigned
that value:</p>
<pre class="literal-block">
# Handle a matched regex
if (match := pattern.search(data)) is not None:
    ...

# A more explicit alternative to the 2-arg form of iter() invocation
while (value := read_next_item()) is not None:
    ...

# Share a subexpression between a comprehension filter clause and its output
filtered_data = [y for x in data if (y := f(x)) is not None]
</pre>
<div class="section" id="differences-from-regular-assignment-statements">
<h2><a class="toc-backref" href="#id5">Differences from regular assignment statements</a></h2>
<p>Most importantly, since <tt class="docutils literal">:=</tt> is an expression, it can be used in contexts
where statements are illegal, including lambda functions and comprehensions.</p>
<p>An assignment statement can assign to multiple targets:</p>
<pre class="literal-block">
x = y = z = 0
</pre>
<p>To do the same with assignment expressions, they must be parenthesized:</p>
<pre class="literal-block">
assert 0 == (x := (y := (z := 0)))
</pre>
<p>Augmented assignment is not supported in expression form:</p>
<pre class="literal-block">
&gt;&gt;&gt; x +:= 1
  File &quot;&lt;stdin&gt;&quot;, line 1
    x +:= 1
        ^
SyntaxError: invalid syntax
</pre>
<p>Otherwise, the semantics of assignment are unchanged by this proposal.</p>
</div>
<div class="section" id="alterations-to-comprehensions">
<h2><a class="toc-backref" href="#id6">Alterations to comprehensions</a></h2>
<p>The current behaviour of list/set/dict comprehensions and generator
expressions has some edge cases that would behave strangely if an assignment
expression were to be used. Therefore the proposed semantics are changed,
removing the current edge cases, and instead altering their behaviour <em>only</em>
in a class scope.</p>
<p>As of Python 3.7, the outermost iterable of any comprehension is evaluated
in the surrounding context, and then passed as an argument to the implicit
function that evaluates the comprehension.</p>
<p>Under this proposal, the entire body of the comprehension is evaluated in
its implicit function. Names not assigned to within the comprehension are
located in the surrounding scopes, as with normal lookups. As one special
case, a comprehension at class scope will <strong>eagerly bind</strong> any name which
is already defined in the class scope.</p>
<p>A list comprehension can be unrolled into an equivalent function. With
Python 3.7 semantics:</p>
<pre class="literal-block">
numbers = [x + y for x in range(3) for y in range(4)]
# Is approximately equivalent to
def &lt;listcomp&gt;(iterator):
    result = []
    for x in iterator:
        for y in range(4):
            result.append(x + y)
    return result
numbers = &lt;listcomp&gt;(iter(range(3)))
</pre>
<p>Under the new semantics, this would instead be equivalent to:</p>
<pre class="literal-block">
def &lt;listcomp&gt;():
    result = []
    for x in range(3):
        for y in range(4):
            result.append(x + y)
    return result
numbers = &lt;listcomp&gt;()
</pre>
<p>When a class scope is involved, a naive transformation into a function would
prevent name lookups (as the function would behave like a method):</p>
<pre class="literal-block">
class X:
    names = [&quot;Fred&quot;, &quot;Barney&quot;, &quot;Joe&quot;]
    prefix = &quot;&gt; &quot;
    prefixed_names = [prefix + name for name in names]
</pre>
<p>With Python 3.7 semantics, this will evaluate the outermost iterable at class
scope, which will succeed; but it will evaluate everything else in a function:</p>
<pre class="literal-block">
class X:
    names = [&quot;Fred&quot;, &quot;Barney&quot;, &quot;Joe&quot;]
    prefix = &quot;&gt; &quot;
    def &lt;listcomp&gt;(iterator):
        result = []
        for name in iterator:
            result.append(prefix + name)
        return result
    prefixed_names = &lt;listcomp&gt;(iter(names))
</pre>
<p>The name <tt class="docutils literal">prefix</tt> is thus searched for at global scope, ignoring the class
name. Under the proposed semantics, this name will be eagerly bound; and the
same early binding then handles the outermost iterable as well. The list
comprehension is thus approximately equivalent to:</p>
<pre class="literal-block">
class X:
    names = [&quot;Fred&quot;, &quot;Barney&quot;, &quot;Joe&quot;]
    prefix = &quot;&gt; &quot;
    def &lt;listcomp&gt;(names=names, prefix=prefix):
        result = []
        for name in names:
            result.append(prefix + name)
        return result
    prefixed_names = &lt;listcomp&gt;()
</pre>
<p>With list comprehensions, this is unlikely to cause any confusion. With
generator expressions, this has the potential to affect behaviour, as the
eager binding means that the name could be rebound between the creation of
the genexp and the first call to <tt class="docutils literal">next()</tt>. It is, however, more closely
aligned to normal expectations.  The effect is ONLY seen with names that
are looked up from class scope; global names (eg <tt class="docutils literal">range()</tt>) will still
be late-bound as usual.</p>
<p>One consequence of this change is that certain bugs in genexps will not
be detected until the first call to <tt class="docutils literal">next()</tt>, where today they would be
caught upon creation of the generator. See 'open questions' below.</p>
</div>
</div>
<div class="section" id="recommended-use-cases">
<h1><a class="toc-backref" href="#id7">Recommended use-cases</a></h1>
<div class="section" id="simplifying-list-comprehensions">
<h2><a class="toc-backref" href="#id8">Simplifying list comprehensions</a></h2>
<p>These list comprehensions are all approximately equivalent:</p>
<pre class="literal-block">
stuff = [[y := f(x), x/y] for x in range(5)]

# There are a number of less obvious ways to spell this in current
# versions of Python.

# Calling the function twice
stuff = [[f(x), x/f(x)] for x in range(5)]

# External helper function
def pair(x, value): return [value, x/value]
stuff = [pair(x, f(x)) for x in range(5)]

# Inline helper function
stuff = [(lambda y: [y,x/y])(f(x)) for x in range(5)]

# Extra 'for' loop - potentially could be optimized internally
stuff = [[y, x/y] for x in range(5) for y in [f(x)]]

# Iterating over a genexp
stuff = [[y, x/y] for x, y in ((x, f(x)) for x in range(5))]

# Expanding the comprehension into a loop
stuff = []
for x in range(5):
    y = f(x)
    stuff.append([y, x/y])

# Wrapping the loop in a generator function
def g():
    for x in range(5):
        y = f(x)
        yield [y, x/y]
stuff = list(g())

# Using a mutable cache object (various forms possible)
c = {}
stuff = [[c.update(y=f(x)) or c['y'], x/c['y']] for x in range(5)]
</pre>
<p>If calling <tt class="docutils literal">f(x)</tt> is expensive or has side effects, the clean operation of
the list comprehension gets muddled. Using a short-duration name binding
retains the simplicity; while the extra <tt class="docutils literal">for</tt> loop does achieve this, it
does so at the cost of dividing the expression visually, putting the named
part at the end of the comprehension instead of the beginning.</p>
<p>Similarly, a list comprehension can map and filter efficiently by capturing
the condition:</p>
<pre class="literal-block">
results = [(x, y, x/y) for x in input_data if (y := f(x)) &gt; 0]
</pre>
</div>
<div class="section" id="capturing-condition-values">
<h2><a class="toc-backref" href="#id9">Capturing condition values</a></h2>
<p>Assignment expressions can be used to good effect in the header of
an <tt class="docutils literal">if</tt> or <tt class="docutils literal">while</tt> statement:</p>
<pre class="literal-block">
# Proposed syntax
while (command := input(&quot;&gt; &quot;)) != &quot;quit&quot;:
    print(&quot;You entered:&quot;, command)

# Capturing regular expression match objects
# See, for instance, Lib/pydoc.py, which uses a multiline spelling
# of this effect
if match := re.search(pat, text):
    print(&quot;Found:&quot;, match.group(0))

# Reading socket data until an empty string is returned
while data := sock.read():
    print(&quot;Received data:&quot;, data)

# Equivalent in current Python, not caring about function return value
while input(&quot;&gt; &quot;) != &quot;quit&quot;:
    print(&quot;You entered a command.&quot;)

# To capture the return value in current Python demands a four-line
# loop header.
while True:
    command = input(&quot;&gt; &quot;);
    if command == &quot;quit&quot;:
        break
    print(&quot;You entered:&quot;, command)
</pre>
<p>Particularly with the <tt class="docutils literal">while</tt> loop, this can remove the need to have an
infinite loop, an assignment, and a condition. It also creates a smooth
parallel between a loop which simply uses a function call as its condition,
and one which uses that as its condition but also uses the actual value.</p>
</div>
</div>
<div class="section" id="rejected-alternative-proposals">
<h1><a class="toc-backref" href="#id10">Rejected alternative proposals</a></h1>
<p>Proposals broadly similar to this one have come up frequently on python-ideas.
Below are a number of alternative syntaxes, some of them specific to
comprehensions, which have been rejected in favour of the one given above.</p>
<div class="section" id="alternative-spellings">
<h2><a class="toc-backref" href="#id11">Alternative spellings</a></h2>
<p>Broadly the same semantics as the current proposal, but spelled differently.</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal">EXPR as NAME</tt>, with or without parentheses:</p>
<pre class="literal-block">
stuff = [[f(x) as y, x/y] for x in range(5)]
</pre>
<p>Omitting the parentheses in this form of the proposal introduces many
syntactic ambiguities.  Requiring them in all contexts leaves open the
option to make them optional in specific situations where the syntax is
unambiguous (cf generator expressions as sole parameters in function
calls), but there is no plausible way to make them optional everywhere.</p>
<p>With the parentheses, this becomes a viable option, with its own tradeoffs
in syntactic ambiguity.  Since <tt class="docutils literal">EXPR as NAME</tt> already has meaning in
<tt class="docutils literal">except</tt> and <tt class="docutils literal">with</tt> statements (with different semantics), this would
create unnecessary confusion or require special-casing (most notably of
<tt class="docutils literal">with</tt> and <tt class="docutils literal">except</tt> statements, where a nearly-identical syntax has
different semantics).</p>
</li>
<li><p class="first"><tt class="docutils literal">EXPR <span class="pre">-&gt;</span> NAME</tt>:</p>
<pre class="literal-block">
stuff = [[f(x) -&gt; y, x/y] for x in range(5)]
</pre>
<p>This syntax is inspired by languages such as R and Haskell, and some
programmable calculators. (Note that a left-facing arrow <tt class="docutils literal">y &lt;- f(x)</tt> is
not possible in Python, as it would be interpreted as less-than and unary
minus.) This syntax has a slight advantage over 'as' in that it does not
conflict with <tt class="docutils literal">with</tt> and <tt class="docutils literal">except</tt> statements, but otherwise is
equivalent.</p>
</li>
<li><p class="first">Adorning statement-local names with a leading dot:</p>
<pre class="literal-block">
stuff = [[(f(x) as .y), x/.y] for x in range(5)] # with &quot;as&quot;
stuff = [[(.y := f(x)), x/.y] for x in range(5)] # with &quot;:=&quot;
</pre>
<p>This has the advantage that leaked usage can be readily detected, removing
some forms of syntactic ambiguity.  However, this would be the only place
in Python where a variable's scope is encoded into its name, making
refactoring harder.  This syntax is quite viable, and could be promoted to
become the current recommendation if its advantages are found to outweigh
its cost.</p>
</li>
<li><p class="first">Adding a <tt class="docutils literal">where:</tt> to any statement to create local name bindings:</p>
<pre class="literal-block">
value = x**2 + 2*x where:
    x = spam(1, 4, 7, q)
</pre>
<p>Execution order is inverted (the indented body is performed first, followed
by the &quot;header&quot;).  This requires a new keyword, unless an existing keyword
is repurposed (most likely <tt class="docutils literal">with:</tt>).  See <a class="reference external" href="/dev/peps/pep-3150">PEP 3150</a> for prior discussion
on this subject (with the proposed keyword being <tt class="docutils literal">given:</tt>).</p>
</li>
<li><p class="first"><tt class="docutils literal">TARGET from EXPR</tt>:</p>
<pre class="literal-block">
stuff = [[y from f(x), x/y] for x in range(5)]
</pre>
<p>This syntax has fewer conflicts than <tt class="docutils literal">as</tt> does (conflicting only with the
<tt class="docutils literal">raise Exc from Exc</tt> notation), but is otherwise comparable to it. Instead
of paralleling <tt class="docutils literal">with expr as target:</tt> (which can be useful but can also be
confusing), this has no parallels, but is evocative.</p>
</li>
</ol>
</div>
<div class="section" id="special-casing-conditional-statements">
<h2><a class="toc-backref" href="#id12">Special-casing conditional statements</a></h2>
<p>One of the most popular use-cases is <tt class="docutils literal">if</tt> and <tt class="docutils literal">while</tt> statements.  Instead
of a more general solution, this proposal enhances the syntax of these two
statements to add a means of capturing the compared value:</p>
<pre class="literal-block">
if re.search(pat, text) as match:
    print(&quot;Found:&quot;, match.group(0))
</pre>
<p>This works beautifully if and ONLY if the desired condition is based on the
truthiness of the captured value.  It is thus effective for specific
use-cases (regex matches, socket reads that return <cite>''</cite> when done), and
completely useless in more complicated cases (eg where the condition is
<tt class="docutils literal">f(x) &lt; 0</tt> and you want to capture the value of <tt class="docutils literal">f(x)</tt>).  It also has
no benefit to list comprehensions.</p>
<p>Advantages: No syntactic ambiguities. Disadvantages: Answers only a fraction
of possible use-cases, even in <tt class="docutils literal">if</tt>/<tt class="docutils literal">while</tt> statements.</p>
</div>
<div class="section" id="special-casing-comprehensions">
<h2><a class="toc-backref" href="#id13">Special-casing comprehensions</a></h2>
<p>Another common use-case is comprehensions (list/set/dict, and genexps). As
above, proposals have been made for comprehension-specific solutions.</p>
<ol class="arabic">
<li><p class="first"><tt class="docutils literal">where</tt>, <tt class="docutils literal">let</tt>, or <tt class="docutils literal">given</tt>:</p>
<pre class="literal-block">
stuff = [(y, x/y) where y = f(x) for x in range(5)]
stuff = [(y, x/y) let y = f(x) for x in range(5)]
stuff = [(y, x/y) given y = f(x) for x in range(5)]
</pre>
<p>This brings the subexpression to a location in between the 'for' loop and
the expression. It introduces an additional language keyword, which creates
conflicts. Of the three, <tt class="docutils literal">where</tt> reads the most cleanly, but also has the
greatest potential for conflict (eg SQLAlchemy and numpy have <tt class="docutils literal">where</tt>
methods, as does <tt class="docutils literal">tkinter.dnd.Icon</tt> in the standard library).</p>
</li>
<li><p class="first"><tt class="docutils literal">with NAME = EXPR</tt>:</p>
<pre class="literal-block">
stuff = [(y, x/y) with y = f(x) for x in range(5)]
</pre>
<p>As above, but reusing the <cite>with</cite> keyword. Doesn't read too badly, and needs
no additional language keyword. Is restricted to comprehensions, though,
and cannot as easily be transformed into &quot;longhand&quot; for-loop syntax. Has
the C problem that an equals sign in an expression can now create a name
binding, rather than performing a comparison. Would raise the question of
why &quot;with NAME = EXPR:&quot; cannot be used as a statement on its own.</p>
</li>
<li><p class="first"><tt class="docutils literal">with EXPR as NAME</tt>:</p>
<pre class="literal-block">
stuff = [(y, x/y) with f(x) as y for x in range(5)]
</pre>
<p>As per option 2, but using <tt class="docutils literal">as</tt> rather than an equals sign. Aligns
syntactically with other uses of <tt class="docutils literal">as</tt> for name binding, but a simple
transformation to for-loop longhand would create drastically different
semantics; the meaning of <tt class="docutils literal">with</tt> inside a comprehension would be
completely different from the meaning as a stand-alone statement, while
retaining identical syntax.</p>
</li>
</ol>
<p>Regardless of the spelling chosen, this introduces a stark difference between
comprehensions and the equivalent unrolled long-hand form of the loop.  It is
no longer possible to unwrap the loop into statement form without reworking
any name bindings.  The only keyword that can be repurposed to this task is
<tt class="docutils literal">with</tt>, thus giving it sneakily different semantics in a comprehension than
in a statement; alternatively, a new keyword is needed, with all the costs
therein.</p>
</div>
</div>
<div class="section" id="migration-path">
<h1><a class="toc-backref" href="#id14">Migration path</a></h1>
<p>The semantic changes to list/set/dict comprehensions, and more so to generator
expressions, may potentially require migration of code. In many cases, the
changes simply make legal what used to raise an exception, but there are some
edge cases that were previously legal and now are not, and a few corner cases
with altered semantics.</p>
<div class="section" id="yield-inside-comprehensions">
<h2><a class="toc-backref" href="#id15">Yield inside comprehensions</a></h2>
<p>As of Python 3.7, the outermost iterable in a comprehension is permitted to
contain a 'yield' expression. If this is required, the iterable (or at least
the yield) must be explicitly elevated from the comprehension:</p>
<pre class="literal-block">
# Python 3.7
def g():
    return [x for x in [(yield 1)]]
# With PEP 572
def g():
    sent_item = (yield 1)
    return [x for x in [sent_item]]
</pre>
<p>This more clearly shows that it is g(), not the comprehension, which is able
to yield values (and is thus a generator function). The entire comprehension
is consistently in a single scope.</p>
</div>
<div class="section" id="name-lookups-in-class-scope">
<h2><a class="toc-backref" href="#id16">Name lookups in class scope</a></h2>
<p>A comprehension inside a class previously was able to 'see' class members ONLY
from the outermost iterable. Other name lookups would ignore the class and
potentially locate a name at an outer scope:</p>
<pre class="literal-block">
pattern = &quot;&lt;%d&gt;&quot;
class X:
    pattern = &quot;[%d]&quot;
    numbers = [pattern % n for n in range(5)]
</pre>
<p>In Python 3.7, <tt class="docutils literal">X.numbers</tt> would show angle brackets; with <a class="reference external" href="/dev/peps/pep-0572">PEP 572</a>, it would
show square brackets. Maintaining the current behaviour here is best done by
using distinct names for the different forms of <tt class="docutils literal">pattern</tt>, as would be the
case with functions.</p>
</div>
<div class="section" id="generator-expression-bugs-can-be-caught-later">
<h2><a class="toc-backref" href="#id17">Generator expression bugs can be caught later</a></h2>
<p>Certain types of bugs in genexps were previously caught more quickly. Some are
now detected only at first iteration:</p>
<pre class="literal-block">
gen = (x for x in rage(10)) # NameError
gen = (x for x in 10) # TypeError (not iterable)
gen = (x for x in range(1/0)) # Exception raised during evaluation
</pre>
<p>This brings such generator expressions in line with a simple translation to
function form:</p>
<pre class="literal-block">
def &lt;genexp&gt;():
    for x in rage(10):
        yield x
gen = &lt;genexp&gt;() # No exception yet
tng = next(gen) # NameError
</pre>
<p>To detect these errors more quickly, ... TODO.</p>
</div>
</div>
<div class="section" id="open-questions">
<h1><a class="toc-backref" href="#id18">Open questions</a></h1>
<div class="section" id="can-the-outermost-iterable-still-be-evaluated-early">
<h2><a class="toc-backref" href="#id19">Can the outermost iterable still be evaluated early?</a></h2>
<p>As of Python 3.7, the outermost iterable in a genexp is evaluated early, and
the result passed to the implicit function as an argument.  With <a class="reference external" href="/dev/peps/pep-0572">PEP 572</a>, this
would no longer be the case. Can we still, somehow, evaluate it before moving
on? One possible implementation would be:</p>
<pre class="literal-block">
gen = (x for x in rage(10))
# translates to
def &lt;genexp&gt;():
    iterable = iter(rage(10))
    yield None
    for x in iterable:
        yield x
gen = &lt;genexp&gt;()
next(gen)
</pre>
<p>This would pump the iterable up to just before the loop starts, evaluating
exactly as much as is evaluated outside the generator function in Py3.7.
This would result in it being possible to call <tt class="docutils literal">gen.send()</tt> immediately,
unlike with most generators, and may incur unnecessary overhead in the
common case where the iterable is pumped immediately (perhaps as part of a
larger expression).</p>
</div>
<div class="section" id="importing-names-into-comprehensions">
<h2><a class="toc-backref" href="#id20">Importing names into comprehensions</a></h2>
<p>A list comprehension can use and update local names, and they will retain
their values from one iteration to another. It would be convenient to use
this feature to create rolling or self-effecting data streams:</p>
<pre class="literal-block">
progressive_sums = [total := total + value for value in data]
</pre>
<p>This will fail with UnboundLocalError due to <tt class="docutils literal">total</tt> not being initalized.
Simply initializing it outside of the comprehension is insufficient - unless
the comprehension is in class scope:</p>
<pre class="literal-block">
class X:
    total = 0
    progressive_sums = [total := total + value for value in data]
</pre>
<p>At other scopes, it may be beneficial to have a way to fetch a value from the
surrounding scope. Should this be automatic? Should it be controlled with a
keyword? Hypothetically (and using no new keywords), this could be written:</p>
<pre class="literal-block">
total = 0
progressive_sums = [total := total + value
    import nonlocal total
    for value in data]
</pre>
<p>Translated into longhand, this would become:</p>
<pre class="literal-block">
total = 0
def &lt;listcomp&gt;(total=total):
    result = []
    for value in data:
        result.append(total := total + value)
    return result
progressive_sums = &lt;listcomp&gt;()
</pre>
<p>ie utilizing the same early-binding technique that is used at class scope.</p>
</div>
<div class="section" id="operator-precedence">
<h2><a class="toc-backref" href="#id21">Operator precedence</a></h2>
<p>There are two logical precedences for the <tt class="docutils literal">:=</tt> operator. Either it should
bind as loosely as possible, as does statement-assignment; or it should bind
more tightly than comparison operators. Placing its precedence between the
comparison and arithmetic operators (to be precise: just lower than bitwise
OR) allows most uses inside <tt class="docutils literal">while</tt> and <tt class="docutils literal">if</tt> conditions to be spelled
without parentheses, as it is most likely that you wish to capture the value
of something, then perform a comparison on it:</p>
<pre class="literal-block">
pos = -1
while pos := buffer.find(search_term, pos + 1) &gt;= 0:
    ...
</pre>
<p>Once find() returns -1, the loop terminates. If <tt class="docutils literal">:=</tt> binds as loosely as
<tt class="docutils literal">=</tt> does, this would capture the result of the comparison (generally either
<tt class="docutils literal">True</tt> or <tt class="docutils literal">False</tt>), which is less useful.</p>
</div>
</div>
<div class="section" id="frequently-raised-objections">
<h1><a class="toc-backref" href="#id22">Frequently Raised Objections</a></h1>
<div class="section" id="why-not-just-turn-existing-assignment-into-an-expression">
<h2><a class="toc-backref" href="#id23">Why not just turn existing assignment into an expression?</a></h2>
<p>C and its derivatives define the <tt class="docutils literal">=</tt> operator as an expression, rather than
a statement as is Python's way.  This allows assignments in more contexts,
including contexts where comparisons are more common.  The syntactic similarity
between <tt class="docutils literal">if (x == y)</tt> and <tt class="docutils literal">if (x = y)</tt> belies their drastically different
semantics.  Thus this proposal uses <tt class="docutils literal">:=</tt> to clarify the distinction.</p>
</div>
<div class="section" id="this-could-be-used-to-create-ugly-code">
<h2><a class="toc-backref" href="#id24">This could be used to create ugly code!</a></h2>
<p>So can anything else.  This is a tool, and it is up to the programmer to use it
where it makes sense, and not use it where superior constructs can be used.</p>
</div>
<div class="section" id="with-assignment-expressions-why-bother-with-assignment-statements">
<h2><a class="toc-backref" href="#id25">With assignment expressions, why bother with assignment statements?</a></h2>
<p>The two forms have different flexibilities.  The <tt class="docutils literal">:=</tt> operator can be used
inside a larger expression; the <tt class="docutils literal">=</tt> operator can be chained more
conveniently, and closely parallels the inline operations <tt class="docutils literal">+=</tt> and friends.
The assignment statement is a clear declaration of intent: this value is to
be assigned to this target, and that's it.</p>
</div>
<div class="section" id="why-not-use-a-sublocal-scope-and-prevent-namespace-pollution">
<h2><a class="toc-backref" href="#id26">Why not use a sublocal scope and prevent namespace pollution?</a></h2>
<p>Previous revisions of this proposal involved sublocal scope (restricted to a
single statement), preventing name leakage and namespace pollution.  While a
definite advantage in a number of situations, this increases complexity in
many others, and the costs are not justified by the benefits. In the interests
of language simplicity, the name bindings created here are exactly equivalent
to any other name bindings, including that usage at class or module scope will
create externally-visible names.  This is no different from <tt class="docutils literal">for</tt> loops or
other constructs, and can be solved the same way: <tt class="docutils literal">del</tt> the name once it is
no longer needed, or prefix it with an underscore.</p>
<p>Names bound within a comprehension are local to that comprehension, even in
the outermost iterable, and can thus be used freely without polluting the
surrounding namespace.</p>
</div>
</div>
<div class="section" id="style-guide-recommendations">
<h1><a class="toc-backref" href="#id27">Style guide recommendations</a></h1>
<p>As this adds another way to spell some of the same effects as can already be
done, it is worth noting a few broad recommendations. These could be included
in <a class="reference external" href="/dev/peps/pep-0008">PEP 8</a> and/or other style guides.</p>
<ol class="arabic simple">
<li>If either assignment statements or assignment expressions can be
used, prefer statements; they are a clear declaration of intent.</li>
<li>If using assignment expressions would lead to ambiguity about
execution order, restructure it to use statements instead.</li>
<li>Chaining multiple assignment expressions should generally be avoided.
More than one assignment per expression can detract from readability.</li>
</ol>
</div>
<div class="section" id="acknowledgements">
<h1><a class="toc-backref" href="#id28">Acknowledgements</a></h1>
<p>The author wishes to thank Guido van Rossum and Nick Coghlan for their
considerable contributions to this proposal, and to members of the
core-mentorship mailing list for assistance with implementation.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id29">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Proof of concept / reference implementation
(<a class="reference external" href="https://github.com/Rosuav/cpython/tree/assignment-expressions">https://github.com/Rosuav/cpython/tree/assignment-expressions</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id30">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

