<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/dev/peps/pep-0001 for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">467</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Minor API improvements for binary sequences</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">$Revision$</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="https://hg.python.org/peps/file/tip/pep-0467.txt">$Date$</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Nick Coghlan &lt;ncoghlan&#32;&#97;t&#32;gmail.com&gt;, Ethan Furman &lt;ethan&#32;&#97;t&#32;stoneleaf.us&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">2014-03-30</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.8</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">2014-03-30 2014-08-15 2014-08-16 2016-06-07 2016-09-01</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id7">Abstract</a></li>
<li><a class="reference internal" href="#proposals" id="id8">Proposals</a><ul>
<li><a class="reference internal" href="#deprecation-of-current-zero-initialised-sequence-behaviour-without-removal" id="id9">Deprecation of current &quot;zero-initialised sequence&quot; behaviour without removal</a></li>
<li><a class="reference internal" href="#addition-of-explicit-count-and-byte-initialised-sequence-constructors" id="id10">Addition of explicit &quot;count and byte initialised sequence&quot; constructors</a></li>
<li><a class="reference internal" href="#addition-of-bchr-function-and-explicit-single-byte-constructors" id="id11">Addition of &quot;bchr&quot; function and explicit &quot;single byte&quot; constructors</a></li>
<li><a class="reference internal" href="#addition-of-getbyte-method-to-retrieve-a-single-byte" id="id12">Addition of &quot;getbyte&quot; method to retrieve a single byte</a></li>
<li><a class="reference internal" href="#addition-of-optimised-iterator-methods-that-produce-bytes-objects" id="id13">Addition of optimised iterator methods that produce <tt class="docutils literal">bytes</tt> objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#design-discussion" id="id14">Design discussion</a><ul>
<li><a class="reference internal" href="#why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences" id="id15">Why not rely on sequence repetition to create zero-initialised sequences?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-questions" id="id16">Open Questions</a></li>
<li><a class="reference internal" href="#references" id="id17">References</a></li>
<li><a class="reference internal" href="#copyright" id="id18">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id7">Abstract</a></h1>
<p>During the initial development of the Python 3 language specification, the
core <tt class="docutils literal">bytes</tt> type for arbitrary binary data started as the mutable type
that is now referred to as <tt class="docutils literal">bytearray</tt>. Other aspects of operating in
the binary domain in Python have also evolved over the course of the Python
3 series.</p>
<p>This PEP proposes five small adjustments to the APIs of the <tt class="docutils literal">bytes</tt> and
<tt class="docutils literal">bytearray</tt> types to make it easier to operate entirely in the binary domain:</p>
<ul class="simple">
<li>Deprecate passing single integer values to <tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt></li>
<li>Add <tt class="docutils literal">bytes.fromsize</tt> and <tt class="docutils literal">bytearray.fromsize</tt> alternative constructors</li>
<li>Add <tt class="docutils literal">bytes.fromord</tt> and <tt class="docutils literal">bytearray.fromord</tt> alternative constructors</li>
<li>Add <tt class="docutils literal">bytes.getbyte</tt> and <tt class="docutils literal">bytearray.getbyte</tt> byte retrieval methods</li>
<li>Add <tt class="docutils literal">bytes.iterbytes</tt> and <tt class="docutils literal">bytearray.iterbytes</tt> alternative iterators</li>
</ul>
<p>And one built-in:</p>
<pre class="literal-block">
* bchr
</pre>
</div>
<div class="section" id="proposals">
<h1><a class="toc-backref" href="#id8">Proposals</a></h1>
<div class="section" id="deprecation-of-current-zero-initialised-sequence-behaviour-without-removal">
<h2><a class="toc-backref" href="#id9">Deprecation of current &quot;zero-initialised sequence&quot; behaviour without removal</a></h2>
<p>Currently, the <tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt> constructors accept an integer
argument and interpret it as meaning to create a zero-initialised sequence
of the given size:</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes(3)
b'\x00\x00\x00'
&gt;&gt;&gt; bytearray(3)
bytearray(b'\x00\x00\x00')
</pre>
<p>This PEP proposes to deprecate that behaviour in Python 3.6, but to leave
it in place for at least as long as Python 2.7 is supported, possibly
indefinitely.</p>
<p>No other changes are proposed to the existing constructors.</p>
</div>
<div class="section" id="addition-of-explicit-count-and-byte-initialised-sequence-constructors">
<h2><a class="toc-backref" href="#id10">Addition of explicit &quot;count and byte initialised sequence&quot; constructors</a></h2>
<p>To replace the deprecated behaviour, this PEP proposes the addition of an
explicit <tt class="docutils literal">fromsize</tt> alternative constructor as a class method on both
<tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt> whose first argument is the count, and whose
second argument is the fill byte to use (defaults to <tt class="docutils literal">\x00</tt>):</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes.fromsize(3)
b'\x00\x00\x00'
&gt;&gt;&gt; bytearray.fromsize(3)
bytearray(b'\x00\x00\x00')
&gt;&gt;&gt; bytes.fromsize(5, b'\x0a')
b'\x0a\x0a\x0a\x0a\x0a'
&gt;&gt;&gt; bytearray.fromsize(5, b'\x0a')
bytearray(b'\x0a\x0a\x0a\x0a\x0a')
</pre>
<p><tt class="docutils literal">fromsize</tt> will behave just as the current constructors behave when passed a single
integer, while allowing for non-zero fill values when needed.</p>
</div>
<div class="section" id="addition-of-bchr-function-and-explicit-single-byte-constructors">
<h2><a class="toc-backref" href="#id11">Addition of &quot;bchr&quot; function and explicit &quot;single byte&quot; constructors</a></h2>
<p>As binary counterparts to the text <tt class="docutils literal">chr</tt> function, this PEP proposes
the addition of a <tt class="docutils literal">bchr</tt> function and an explicit <tt class="docutils literal">fromord</tt> alternative
constructor as a class method on both <tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; bchr(ord(&quot;A&quot;))
b'A'
&gt;&gt;&gt; bchr(ord(b&quot;A&quot;))
b'A'
&gt;&gt;&gt; bytes.fromord(65)
b'A'
&gt;&gt;&gt; bytearray.fromord(65)
bytearray(b'A')
</pre>
<p>These methods will only accept integers in the range 0 to 255 (inclusive):</p>
<pre class="literal-block">
&gt;&gt;&gt; bytes.fromord(512)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
ValueError: integer must be in range(0, 256)

&gt;&gt;&gt; bytes.fromord(1.0)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
TypeError: 'float' object cannot be interpreted as an integer
</pre>
<p>While this does create some duplication, there are valid reasons for it:</p>
<ul class="simple">
<li>the <tt class="docutils literal">bchr</tt> builtin is to recreate the ord/chr/unichr trio from Python
2 under a different naming scheme</li>
<li>the class method is mainly for the <tt class="docutils literal">bytearray.fromord</tt> case, with
<tt class="docutils literal">bytes.fromord</tt> added for consistency</li>
</ul>
<p>The documentation of the <tt class="docutils literal">ord</tt> builtin will be updated to explicitly note
that <tt class="docutils literal">bchr</tt> is the primary inverse operation for binary data, while <tt class="docutils literal">chr</tt>
is the inverse operation for text data, and that <tt class="docutils literal">bytes.fromord</tt> and
<tt class="docutils literal">bytearray.fromord</tt> also exist.</p>
<p>Behaviourally, <tt class="docutils literal">bytes.fromord(x)</tt> will be equivalent to the current
<tt class="docutils literal"><span class="pre">bytes([x])</span></tt> (and similarly for <tt class="docutils literal">bytearray</tt>). The new spelling is
expected to be easier to discover and easier to read (especially when used
in conjunction with indexing operations on binary sequence types).</p>
<p>As a separate method, the new spelling will also work better with higher
order functions like <tt class="docutils literal">map</tt>.</p>
</div>
<div class="section" id="addition-of-getbyte-method-to-retrieve-a-single-byte">
<h2><a class="toc-backref" href="#id12">Addition of &quot;getbyte&quot; method to retrieve a single byte</a></h2>
<p>This PEP proposes that <tt class="docutils literal">bytes</tt> and <tt class="docutils literal">bytearray</tt> gain the method <tt class="docutils literal">getbyte</tt>
which will always return <tt class="docutils literal">bytes</tt>:</p>
<pre class="literal-block">
&gt;&gt;&gt; b'abc'.getbyte(0)
b'a'
</pre>
<p>If an index is asked for that doesn't exist, <tt class="docutils literal">IndexError</tt> is raised:</p>
<pre class="literal-block">
&gt;&gt;&gt; b'abc'.getbyte(9)
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
IndexError: index out of range
</pre>
</div>
<div class="section" id="addition-of-optimised-iterator-methods-that-produce-bytes-objects">
<h2><a class="toc-backref" href="#id13">Addition of optimised iterator methods that produce <tt class="docutils literal">bytes</tt> objects</a></h2>
<p>This PEP proposes that <tt class="docutils literal">bytes</tt> and <tt class="docutils literal"><span class="pre">bytearray``gain</span> an optimised
``iterbytes</tt> method that produces length 1 <tt class="docutils literal">bytes</tt> objects rather than
integers:</p>
<pre class="literal-block">
for x in data.iterbytes():
    # x is a length 1 ``bytes`` object, rather than an integer
</pre>
<p>For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; tuple(b&quot;ABC&quot;.iterbytes())
(b'A', b'B', b'C')
</pre>
</div>
</div>
<div class="section" id="design-discussion">
<h1><a class="toc-backref" href="#id14">Design discussion</a></h1>
<div class="section" id="why-not-rely-on-sequence-repetition-to-create-zero-initialised-sequences">
<h2><a class="toc-backref" href="#id15">Why not rely on sequence repetition to create zero-initialised sequences?</a></h2>
<p>Zero-initialised sequences can be created via sequence repetition:</p>
<pre class="literal-block">
&gt;&gt;&gt; b'\x00' * 3
b'\x00\x00\x00'
&gt;&gt;&gt; bytearray(b'\x00') * 3
bytearray(b'\x00\x00\x00')
</pre>
<p>However, this was also the case when the <tt class="docutils literal">bytearray</tt> type was originally
designed, and the decision was made to add explicit support for it in the
type constructor. The immutable <tt class="docutils literal">bytes</tt> type then inherited that feature
when it was introduced in <a class="reference external" href="/dev/peps/pep-3137">PEP 3137</a>.</p>
<p>This PEP isn't revisiting that original design decision, just changing the
spelling as users sometimes find the current behaviour of the binary sequence
constructors surprising. In particular, there's a reasonable case to be made
that <tt class="docutils literal">bytes(x)</tt> (where <tt class="docutils literal">x</tt> is an integer) should behave like the
<tt class="docutils literal">bytes.fromord(x)</tt> proposal in this PEP. Providing both behaviours as separate
class methods avoids that ambiguity.</p>
</div>
</div>
<div class="section" id="open-questions">
<h1><a class="toc-backref" href="#id16">Open Questions</a></h1>
<p>Do we add <tt class="docutils literal">iterbytes</tt> to <tt class="docutils literal">memoryview</tt>, or modify
<tt class="docutils literal">memoryview.cast()</tt> to accept <tt class="docutils literal">'s'</tt> as a single-byte interpretation?  Or
do we ignore memory for now and add it later?</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id17">References</a></h1>
<table class="docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Initial March 2014 discussion thread on python-ideas
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027295.html">https://mail.python.org/pipermail/python-ideas/2014-March/027295.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Guido's initial feedback in that thread
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027376.html">https://mail.python.org/pipermail/python-ideas/2014-March/027376.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Issue proposing moving zero-initialised sequences to a dedicated API
(<a class="reference external" href="http://bugs.python.org/issue20895">http://bugs.python.org/issue20895</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Issue proposing to use calloc() for zero-initialised binary sequences
(<a class="reference external" href="http://bugs.python.org/issue21644">http://bugs.python.org/issue21644</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td>August 2014 discussion thread on python-dev
(<a class="reference external" href="https://mail.python.org/pipermail/python-ideas/2014-March/027295.html">https://mail.python.org/pipermail/python-ideas/2014-March/027295.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td>June 2016 discussion thread on python-dev
(<a class="reference external" href="https://mail.python.org/pipermail/python-dev/2016-June/144875.html">https://mail.python.org/pipermail/python-dev/2016-June/144875.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id18">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
</div>

